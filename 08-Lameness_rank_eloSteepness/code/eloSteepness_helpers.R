################################################################################
############################# functions ########################################
################################################################################
# handle ties: duplicate the rows where degree = 0, 1 row: A wins over B, 2nd row: B wins over A
swap_winner_loser <- function(df, lt1_tie) {
  
  # Check if the input is a data.frame
  if (!is.data.frame(df)) {
    stop("The input must be a data.frame.")
  }
  
  # Check if the necessary columns exist in the data.frame
  necessary_cols <- c("winner", "loser", "degree")
  if (!all(necessary_cols %in% names(df))) {
    stop(paste("The data.frame must contain the following columns:", paste(necessary_cols, collapse = ", ")))
  }
  
  # Subset the data where degree equals 0
  # if lt1_tie == TRUE, meaning that we want to treat degree <1 as tie
  if (lt1_tie) {
    df_subset <- subset(df, degree < 1)
  } else {  # if lt1_tie == FALSE, meaning that we want to treat degree ==0 as tie
    df_subset <- subset(df, degree == 0)
  }
  
  
  # Swap 'winner' and 'loser' in the subset
  df_subset$tmp <- df_subset$winner
  df_subset$winner <- df_subset$loser
  df_subset$loser <- df_subset$tmp
  df_subset$tmp <- NULL
  
  # Append the subset to the original dataframe
  new_df <- rbind(df, df_subset)
  new_df <- new_df[sample(nrow(new_df)), ]
  rownames(new_df) <- NULL
  
  
  return(new_df)
}

# store the Elo winning probability from each iteration
individual_elo_win <- function(array_3d, ids) {
  # Initialize an empty matrix with appropriate dimensions
  res <- matrix(ncol = dim(array_3d)[3], nrow = length(array_3d[, , 1]))
  
  # Fill the matrix with the values from the 3D array
  for (i in seq_len(ncol(res))) {
    res[, i] <- array_3d[, , i]
  }
  
  # Set the column names of the matrix
  colnames(res) <- ids
  
  return(res)
}


plot_scores <- function(x, gs_record, adjustpar = 4, subset_ids = NULL, include_others = TRUE) {
  # Create a color generating function with softer colors
  colfunc <- colorRampPalette(rev(brewer.pal(9, "RdYlGn")))
  
  correct_object <- FALSE
  if ("cumwinprobs" %in% names(x)) {
    res <- individual_elo_win(x$cumwinprobs, x$ids)
    xlab <- "summed Elo winning probability"
    correct_object <- TRUE
  }
  if ("norm_ds" %in% names(x)) {
    res <- x$norm_ds
    xlab <- "David's score (normalized)"
    correct_object <- TRUE
  }
  
  if (!correct_object) {
    stop("object 'x' not of correct format")
  }
  
  n_ids <- ncol(res)
  
  if (!is.null(subset_ids)) {
    colnames(res) <- x$ids
    cn_locs <- which(!x$ids %in% subset_ids)
  }
  
  # prep data and set axis limits
  pdata <- apply(res, 2, density, adjust = adjustpar)
  pmax <- max(unlist(lapply(pdata, function(x) max(x$y))))
  xl <- c(0, n_ids - 1)
  yl <- c(0, pmax * 1.05)
  
  # Generate colors based on gs_record values
  cols <- sapply(colnames(res), function(id) {
    record <- gs_record[gs_record$Cow == id, ]
    if (nrow(record) == 0) {
      return("black")
    } else {
      value <- record$GS
      if (value < 2) value <- 2
      if (value > 4) value <- 4
      return(colfunc(21)[round((value - 2) * 10) + 1])
    }
  })
  
  border_cols <- rep("black", n_ids)
  if (!is.null(subset_ids)) {
    cols[cn_locs] <- NA
    if (!include_others) {
      border_cols[cn_locs] <- NA
    }
  }
  
  # setup
  plot(0, 0, type = "n", xlim = xl, ylim = yl, yaxs = "i",
       xaxs = "i", axes = FALSE, xlab = "", ylab = "", bg = "white")
  title(ylab = "density", line = 1)
  title(xlab = xlab, line = 1.8)
  
  # draw the filled posteriors
  for (i in seq_len(ncol(res))) {
    p <- pdata[[i]]
    p$x[p$x > (n_ids - 1)] <- n_ids - 1
    p$x[p$x < 0] <- 0
    polygon(c(p$x, rev(p$x)), c(rep(0, length(p$x)), rev(p$y)),
            border = NA, col = cols[i])
  }
  
  # draw the contours
  for (i in seq_len(ncol(res))) {
    p <- pdata[[i]]
    p$x[p$x > (n_ids - 1)] <- n_ids - 1
    p$x[p$x < 0] <- 0
    polygon(c(p$x, rev(p$x)), c(rep(0, length(p$x)), rev(p$y)), border = border_cols[i])
  }
}


#' Save Plot to PNG File
#'
#' This function saves a plot generated by the `plot_scores2` function to a PNG file.
#'
#' @param elo_steep_result A result object from the EloSteepness analysis.
#' @param png_name A character string specifying the name of the PNG file (without the .png extension).
#' @param gs_record2 gait score record
#'
#' @return NULL. The function saves the plot to a PNG file and does not return any value.
save_plot_score <- function(elo_steep_result, png_name, gs_record2) {
  file_name <- paste(png_name, ".png", sep = "")
  png(file_name, width = 1106, height = 550) # set the width and height of the PNG file
  print(plot_scores(elo_steep_result, gs_record2))
  dev.off() # close the PNG file
}

# replicate row is degree > 1
# Define a function to replicate each row
replicate_row <- function(row) {
  degree <- as.numeric(row[which(names(winner_loser) == "degree")])
  if (degree > 1) {
    replicate(degree - 1, row, simplify = FALSE)
  } else {
    NULL
  }
}

# replicate row is degree > 1 for every row in this dataframe
replicate_row_df <- function(winner_loser) {
  # replicate row is degree > 1
  # Apply the function to each row of the data frame
  replicated_rows <- apply(winner_loser, 1, replicate_row)
  # Remove NULL elements
  replicated_rows <- replicated_rows[sapply(replicated_rows, length) > 0]
  # Unlist the result and convert it back to a data frame
  winner_loser_replicated <- do.call(rbind, unlist(replicated_rows, recursive = FALSE))
  # Bind the replicated rows with the original data frame
  winner_loser_degree_replct <- rbind(winner_loser, winner_loser_replicated)
  winner_loser_degree_replct <- winner_loser_degree_replct[order(winner_loser_degree_replct$winner, winner_loser_degree_replct$loser),]
  
  return(winner_loser_degree_replct)
}

#' Random Elo Steepness Calculation and Saving
#'
#' This function calculates the Elo steepness from a given winner-loser sheet, 
#' compares it with expert Elo steepness, and saves the results to specified output directories.
#'
#' @param winn_loser_sheet A data frame containing winner and loser data.
#' @param expert_eloSteep A data frame containing expert Elo steepness data.
#' @param output_dir A character string specifying the directory to save output files.
#' @param type A character string specifying the type of analysis: what method is used in the calculation
#' @param assessor A character string specifying the assessor type: expert or click_worker
#' @param gs_record2 gait score record
#'
#' @return NULL. The function saves results to files and does not return any value.
random_elo_steep <- function(winn_loser_sheet, expert_eloSteep, output_dir, type, assessor, gs_record2){
  interaction_matrix <- with(winn_loser_sheet, table(winner, loser))
  
  # use elosteepness from matrix
  elo_baysian_result <- elo_steepness_from_matrix(interaction_matrix, 
                                                  algo="fixed_sd", 
                                                  cores = 4,
                                                  chains = 4,
                                                  iter = 5000, 
                                                  warmup = 1000,
                                                  seed = 88,)
  
  # get individual's score
  individual_elo_win_df <- individual_elo_win(elo_baysian_result$cumwinprobs, elo_baysian_result$ids)
  score_sum <- scores(elo_baysian_result)
  colnames(score_sum)[colnames(score_sum) == "id"] <- "Cow"
  score_sum2_click_worker <- score_sum[, c("Cow", "mean", "sd")]
  colnames(score_sum2_click_worker) <- c("Cow", paste(type, assessor, "mean", sep = "_"), paste(type, assessor,"sd", sep = "_"))
  
  compare_result_master <- merge(expert_eloSteep, score_sum2_click_worker, all = TRUE)
  compare_result_master <- compare_result_master[order(compare_result_master$GS, decreasing = TRUE), ]
  
  # compute Elo steepness
  elo_steep_df <- steepness_df_construct(elo_baysian_result[["steepness"]], type, assessor) 
  
  write.csv(score_sum2_click_worker, file = paste0(output_dir, type, "_", assessor, "_scores.csv"), row.names = FALSE)
  write.csv(individual_elo_win_df, file = paste0(output_dir, type, "_", assessor, "_cumwinprobs.csv"), row.names = FALSE)
  write.csv(compare_result_master, file = paste0(output_dir, "compare_summary.csv"), row.names = FALSE)
  write.csv(elo_steep_df, file = paste0(output_dir, type, "_", assessor, "_steepness.csv"), row.names = FALSE)
  save(elo_baysian_result, file = paste0(output_dir, type, "_", assessor, "_elo_baysian.rdata"))
  save_plot_score(elo_baysian_result, paste0("../plots/", type, "_", assessor), gs_record2)
  
  return(compare_result_master)
}

count_unique_worker_per_HIT <- function(cowLR_df){
  HIT_worker <- unique(cowLR_df[,c("HIT","Worker_id")])
  count_worker_per_HIT <- HIT_worker %>%
    group_by(HIT) %>%
    summarise(count = n())
  colnames(count_worker_per_HIT) <- c("HIT", "worker_num")
  
  return(count_worker_per_HIT)
}


steepness_df_construct <- function(steepness_values, type, assessor) {
  steep_mean <- round(mean(steepness_values), digits = 2)
  steep_sd <- round(sd(steepness_values), digits = 2)
  method <- paste0(type, "_", assessor)
  elo_steep_df <- data.frame(method, steep_mean, steep_sd)
  colnames(elo_steep_df) <- c("method", "steepness_mean", "steepness_SD")
  
  return(elo_steep_df)
}

count_unique_worker_per_pair <- function(cowLR_df){
  HIT_qNum_worker <- unique(cowLR_df[,c("HIT", "question_num", "Worker_id")])
  HIT_qNum_worker$id <- paste(HIT_qNum_worker$HIT, HIT_qNum_worker$question_num, sep = "-")
  count_worker_per_pair <- HIT_qNum_worker %>%
    group_by(id) %>%
    summarise(count = n())
  colnames(count_worker_per_pair) <- c("q_name", "worker_num")
  
  return(count_worker_per_pair)
}